class Pixiurge.TmxMap extends Pixiurge.Displayable
  constructor: (pixi_display, item_name, item_data) ->
    super(pixi_display, item_name, item_data)

    @url = item_data.url
    PIXI.loader.add(@url).load(() => @makeTiledWorld())

  # This is actually the "destroy" method for this Displayable
  hide: () ->

  # Partially adapted from kittykatattack's tileUtilities
  makeTiledWorld: () ->
    tiledMap = PIXI.loader.resources[@url].data;
    world = new PIXI.Container();

    world.tileheight = tiledMap.tileheight;
    world.tilewidth = tiledMap.tilewidth;

    # @todo Needed?
    world.worldWidth = tiledMap.width * tiledMap.tilewidth;
    world.worldHeight = tiledMap.height * tiledMap.tileheight;

    # @todo Change interface?
    world.widthInTiles = tiledMap.width;
    world.heightInTiles = tiledMap.height;

    # @todo Adapt frame-building code from DCJS

#/*
#  ###makeTiledWorld
#  `makeTiledWorld` is a quick and easy way to display a game world designed in
#  Tiled Editor. Supply `makeTiledWorld` with 2 **string arguments**: 
#  
#  1. A JSON file generated by Tiled Editor. 
#  2. A source image that represents the tile set you used to create the Tiled Editor world.
#  ```js
#  let world = makeTiledWorld("tiledEditorMapData.json", "tileset.png");
#  ```
#  (Note: `makeTiledWorld` looks for the JSON data file in Pixi's `loader.resources` object. So, 
#  make sure you've loaded the JSON file using Pixi's `loader`.)
#  `makeTiledWorld` will return a Pixi `Container` that contains all the things in your Tiled Editor
#  map as Pixi sprites.
#  All the image tiles you create in Tiled Editor are automatically converted into Pixi sprites
#  for you by `makeTiledWorld`. You can access all of them using two methods: `getObject` (for
#  single sprites) and `getObjects` (with an "s") for multiple sprites. Let's find out how they work.
#  
#  ####world.getObject
#  Tile Editor lets you assign a "name" properties any object.
#  You can access any sprite by this name using the `getObject` method. `getObject` searches for and
#  returns a sprite in the `world` that has the same `name` property that you assigned
#  in Tiled Editor. Here's how to use `getObject` to look for an object called "alien"
#  in the Tiled map data and assign it to a variable called `alien`
#
#####Accessing Tiled Editor layer groups 
#  
#  Tiled Editor lets you create **layer groups**. Each layer group you create
#  in Tiled Editor is automatically converted by `makeTiledWorld` into a Pixi `Container`
#  object. You can access those containers using `getObject` to extract the layer group
#  container. 
#  Here's how you could extract the layer group called "objects" and add the 
#  `elf` sprite to it.
#  ```js
#  let objectsLayer = world.getObject("objects");
#  objectsLayer.addChild(elf);
#  ```
#  If you want to add the sprite to a different world layer, you can do it like this:
#  ```js
#  world.getObject("treeTops").addChild(elf);
#  ```
#  If you want to access all the sprites in a specific Tiled Editor layer, just supply
#  `getObject` with the name of the layer. For example, if the layer name is "items", you
#  can access it like this:
#  ```js
#  let itemsLayer = world.getObject("items");
#  ```
#  `itemsLayer` is now a Pixi container with a `children` array that contains all the sprites
#  on that layer.  
#  To be safe, clone this array to create a new version
#  that doesn't point to the original data file:
#  ```js
#  items = itemsLayer.children.slice(0);  
#  ```
#  You can now manipulate the `items` array freely without worrying about changing
#  the original array. This can possibly help prevent some weird bugs in a complex game.
#  ###Finding the "gid" values
#  Tiled Editor uses "gid" numbers to identify different kinds of things in the world.
#  If you ever need to extract sprites with specific `gid` numbers in a 
#  layer that contains different kinds of things, you can do it like this:
#  ```js
#  let items = itemsLayer.children.map(sprite => {
#    if (sprite.gid !== 0) return sprite; 
#  });
#  ```
#  Every sprite created by `makeTiledWorld` has a `gid` property with a value that matches its
#  Tiled Editor "gid" value.
#  ####Accessing a layer's "data" array
#  Tiled Editor's layers have a `data` property
#  that is an array containing all the grid index numbers (`gid`) of
#  the tiles in that array. Imagine that you've got a layer full of similar
#  tiles representing the walls in a game. How do you access the array
#  containing all the "gid" numbers of the wall sprites in that layer? If the layer's name is called "wallLayer", you 
#  can access the `wallLayer`'s `data` array of sprites like this: 
#  ```js
#  wallMapArray = world.getObject("wallLayer").data;
#  ```
#  `wallMapArray` is now an array of "gid" numbers referring to all the sprites on that
#  layer. You can now use this data for collision detection, or doing any other kind
#  of world building.
#  ###world.getObjects
#  There's another method called `getObjects` (with an "s"!) that lets you extract
#  an array of sprites from the Tiled Editor data. Imagine that you created three
#  game objects in Tiled Editor called "marmot", "skull" and "heart". `makeTiledWorld`
#  automatically turns them into sprites, and you can access
#  all of them as array of sprites using `getObjects` like this:
#  ```js
#  let gameItemsArray = world.getObjects("marmot", "skull", "heart");
#  ```
#  */
#
#  makeTiledWorld(jsonTiledMap, tileset) {
#
#
#    //Loop through all the map layers
#    tiledMap.layers.forEach(tiledLayer => {
#
#      //Make a group for this layer and copy
#      //all of the layer properties onto it.
#      let layerGroup = new this.Container();
#
#      Object.keys(tiledLayer).forEach(key => {
#        //Add all the layer's properties to the group, except the
#        //width and height (because the group will work those our for
#        //itself based on its content).
#        if (key !== "width" && key !== "height") {
#          layerGroup[key] = tiledLayer[key];
#        }
#      });
#
#      //Set the width and height of the layer to
#      //the `world`'s width and height
#      //layerGroup.width = world.width;
#      //layerGroup.height = world.height;
#
#      //Translate `opacity` to `alpha`
#      layerGroup.alpha = tiledLayer.opacity;
#
#      //Add the group to the `world`
#      world.addChild(layerGroup);
#
#      //Push the group into the world's `objects` array
#      //So you can access it later
#      world.objects.push(layerGroup);
#
#      //Is this current layer a `tilelayer`?
#      if (tiledLayer.type === "tilelayer") {
#
#        //Loop through the `data` array of this layer
#        tiledLayer.data.forEach((gid, index) => {
#          let tileSprite, texture, mapX, mapY, tilesetX, tilesetY,
#            mapColumn, mapRow, tilesetColumn, tilesetRow;
#
#          //If the grid id number (`gid`) isn't zero, create a sprite
#          if (gid !== 0) {
#
#            //Figure out the map column and row number that we're on, and then
#            //calculate the grid cell's x and y pixel position.
#            mapColumn = index % world.widthInTiles;
#            mapRow = Math.floor(index / world.widthInTiles);
#            mapX = mapColumn * world.tilewidth;
#            mapY = mapRow * world.tileheight;
#
#            //Figure out the column and row number that the tileset
#            //image is on, and then use those values to calculate
#            //the x and y pixel position of the image on the tileset
#            tilesetColumn = ((gid - 1) % numberOfTilesetColumns);
#            tilesetRow = Math.floor((gid - 1) / numberOfTilesetColumns);
#            tilesetX = tilesetColumn * world.tilewidth;
#            tilesetY = tilesetRow * world.tileheight;
#
#            //Compensate for any optional spacing (padding) around the tiles if
#            //there is any. This bit of code accumlates the spacing offsets from the
#            //left side of the tileset and adds them to the current tile's position
#            if (spacing > 0) {
#              tilesetX += spacing + (spacing * ((gid - 1) % numberOfTilesetColumns));
#              tilesetY += spacing + (spacing * Math.floor((gid - 1) / numberOfTilesetColumns));
#            }
#
#            //Use the above values to create the sprite's image from
#            //the tileset image
#            texture = this.frame(
#              tileset, tilesetX, tilesetY,
#              world.tilewidth, world.tileheight
#            );
#
#            //I've dedcided that any tiles that have a `name` property are important
#            //and should be accessible in the `world.objects` array.
#
#            let tileproperties = tiledMap.tilesets[0].tileproperties,
#              key = String(gid - 1);
#
#            tileSprite = new this.Sprite(texture);
#
#            //Position the sprite on the map
#            tileSprite.x = mapX;
#            tileSprite.y = mapY;
#
#            //Make a record of the sprite's index number in the array
#            //(We'll use this for collision detection later)
#            tileSprite.index = index;
#
#            //Make a record of the sprite's `gid` on the tileset.
#            //This will also be useful for collision detection later
#            tileSprite.gid = gid;
#
#            //Add the sprite to the current layer group
#            layerGroup.addChild(tileSprite);
#          }
#        });
#      }
#
#    });
